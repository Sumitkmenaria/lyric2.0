
import React, { useState, useCallback, useEffect } from 'react';
import InputForm from './components/InputForm';
import VideoPreview from './components/VideoPreview';
import TimelineEditor from './components/TimelineEditor';
import Header from './components/Header';
import Loader from './components/Loader';
import { structureLyrics, extractLyricsFromAudio } from './services/geminiService';
import { extractColors } from './services/colorExtractor';
import { exportVideo } from './services/videoExporter';
import { AppState, View, AspectRatio, Lyric, HindiFont, VisualizationStyle } from './types';

const initialAppState: AppState = {
  view: View.INPUT,
  audioFile: null,
  imageFile: null,
  audioUrl: null,
  audioDuration: 0,
  imageUrl: null,
  rawLyrics: '',
  structuredLyrics: [],
  error: null,
  isLoading: false,
  isExporting: false,
  exportProgress: 0,
  songName: '',
  creatorName: '',
  aspectRatio: '16:9',
  visualizationStyle: 'classic',
  imageColors: [],
  hindiFont: 'Mukta',
  loaderMessage: '',
  wasTimingAutoGenerated: false,
};

const App: React.FC = () => {
  const [appState, setAppState] = useState<AppState>(initialAppState);
  const [isStateRestored, setIsStateRestored] = useState(false);

  useEffect(() => {
    // Restore state from localStorage on initial load
    try {
      const savedStateJSON = localStorage.getItem('lyricVideoDraft');
      if (savedStateJSON) {
        const savedState = JSON.parse(savedStateJSON);
        // Create URLs for saved files if they exist
        let audioUrl = null;
        let imageUrl = null;
        
        if (savedState.audioFile) {
          try {
            audioUrl = URL.createObjectURL(savedState.audioFile);
          } catch (e) {
            console.warn('Could not restore audio file');
          }
        }
        
        if (savedState.imageFile) {
          try {
            imageUrl = URL.createObjectURL(savedState.imageFile);
          } catch (e) {
            console.warn('Could not restore image file');
          }
        }
        
        setAppState(prev => ({
            ...prev,
            ...savedState,
            audioUrl,
            imageUrl,
        }));
      }
    } catch (error) {
        console.error("Failed to load state from localStorage", error);
    }
    setIsStateRestored(true);
  }, []);

  useEffect(() => {
    // Save state to localStorage on change, but only serializable data
    if (!isStateRestored) return;
    const debouncedSave = setTimeout(() => {
        const { audioUrl, imageUrl, isLoading, isExporting, error, loaderMessage, ...stateToSave } = appState;
        localStorage.setItem('lyricVideoDraft', JSON.stringify(stateToSave));
    }, 500);

    return () => clearTimeout(debouncedSave);
  }, [appState, isStateRestored]);

  const handleLyricsTranscription = useCallback(async (audioFile: File) => {
    setAppState(prev => ({ ...prev, isLoading: true, loaderMessage: 'AI is transcribing your audio...' }));
    try {
        const structured = await extractLyricsFromAudio(audioFile);
        setAppState(prev => ({
            ...prev,
            rawLyrics: structured.map(l => l.text).join('\n'),
            structuredLyrics: structured,
            wasTimingAutoGenerated: true,
            isLoading: false,
            loaderMessage: '',
        }));
    } catch (e) {
      const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during transcription.';
      setAppState(prev => ({ ...prev, error: errorMessage, isLoading: false, loaderMessage: '' }));
    }
  }, []);

  const handleCreateClick = useCallback(async (data: { audio: File; image: File; lyrics: string; songName: string; creatorName: string; aspectRatio: AspectRatio; hindiFont: HindiFont; visualizationStyle: VisualizationStyle; prestructuredLyrics: Lyric[] | null }) => {
    setAppState(prev => ({ ...prev, isLoading: true, error: null, isExporting: false, loaderMessage: "AI is processing your request..." }));
    try {
      const imageUrl = URL.createObjectURL(data.image);
      const audioUrl = URL.createObjectURL(data.audio);
      
      const lyricsPromise = data.prestructuredLyrics 
          ? Promise.resolve(data.prestructuredLyrics)
          : structureLyrics(data.lyrics);
      
      const [structuredLyrics, imageColors] = await Promise.all([
        lyricsPromise,
        extractColors(imageUrl)
      ]);

      setAppState(prev => ({
        ...prev,
        view: View.PREVIEW,
        audioFile: data.audio,
        imageFile: data.image,
        audioUrl,
        imageUrl,
        rawLyrics: data.lyrics,
        structuredLyrics,
        isLoading: false,
        songName: data.songName,
        creatorName: data.creatorName,
        aspectRatio: data.aspectRatio,
        visualizationStyle: data.visualizationStyle,
        imageColors,
        hindiFont: data.hindiFont,
        loaderMessage: '',
        wasTimingAutoGenerated: !!data.prestructuredLyrics,
      }));
    } catch (error) {
      console.error('Failed to generate video preview:', error);
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
      setAppState(prev => ({ ...prev, isLoading: false, error: `Failed to process your request. ${errorMessage}`, loaderMessage: '' }));
    }
  }, []);

  const handleNewProject = () => {
      if (window.confirm("Are you sure you want to start a new project? Your current work will be cleared.")) {
          if (appState.audioUrl) URL.revokeObjectURL(appState.audioUrl);
          if (appState.imageUrl) URL.revokeObjectURL(appState.imageUrl);
          localStorage.removeItem('lyricVideoDraft');
          setAppState(initialAppState);
      }
  };

  const handleBackToInput = () => {
    setAppState(prev => ({
      ...prev,
      view: View.INPUT,
      error: null,
    }));
  };

  const handleSettingsChange = (settings: { aspectRatio: AspectRatio; hindiFont: HindiFont; visualizationStyle: VisualizationStyle }) => {
    setAppState(prev => ({
      ...prev,
      ...settings,
    }));
  };

  const handleExport = async () => {
    if (!appState.audioUrl || !appState.imageUrl) return;
    
    setAppState(prev => ({ 
      ...prev, 
      isExporting: true, 
      error: null, 
      exportProgress: 0, 
      loaderMessage: "Initializing video export...",
      view: View.PREVIEW // Stay on preview during export
    }));
    
    const onProgress = (progress: number) => {
        setAppState(prev => ({
            ...prev,
            exportProgress: progress,
            loaderMessage: progress < 0.1 ? "Setting up video recording..." :
                          progress < 0.9 ? `Recording video... ${Math.round(progress * 100)}%` :
                          progress < 1 ? "Finalizing video..." : "Video exported successfully!"
        }));
    };

    try {
      await exportVideo({
        audioUrl: appState.audioUrl,
        imageUrl: appState.imageUrl,
        lyrics: appState.structuredLyrics,
        songName: appState.songName,
        creatorName: appState.creatorName,
        aspectRatio: appState.aspectRatio,
        visualizationStyle: appState.visualizationStyle,
        imageColors: appState.imageColors,
        hindiFont: appState.hindiFont,
      }, onProgress);
      
      // Show success message briefly
      setTimeout(() => {
        setAppState(prev => ({ ...prev, isExporting: false, loaderMessage: "", exportProgress: 0 }));
      }, 2000);
    } catch (error) {
       console.error('Failed to export video:', error);
       const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
       setAppState(prev => ({ ...prev, error: `Failed to export video. ${errorMessage}` }));
       setAppState(prev => ({ ...prev, isExporting: false, loaderMessage: "", exportProgress: 0 }));
    }
  };

  const handleAdjustLyrics = (duration: number) => {
    let lyricsToEdit = appState.structuredLyrics;
    if (!lyricsToEdit.some(l => l.startTime > 0)) {
        const lyricCount = lyricsToEdit.length;
        const introBuffer = 3; // 3-second intro
        const playableDuration = duration - introBuffer;
        lyricsToEdit = lyricsToEdit.map((lyric, index) => ({
            ...lyric,
            startTime: introBuffer + (index / lyricCount) * playableDuration
        }));
    }

    setAppState(prev => ({
        ...prev,
        view: View.TIMELINE_EDITOR,
        audioDuration: duration,
        structuredLyrics: lyricsToEdit
    }));
  };
  
  const handleAdjustLyricsFromInput = (lyrics: Lyric[]) => {
    setAppState(prev => ({
      ...prev,
      view: View.TIMELINE_EDITOR,
      structuredLyrics: lyrics,
      audioDuration: 180, // Default duration for timeline editor
    }));
  };

  const handleSaveTimeline = (updatedLyrics: Lyric[]) => {
      setAppState(prev => ({
          ...prev,
          structuredLyrics: updatedLyrics,
          view: View.PREVIEW,
          wasTimingAutoGenerated: true,
      }));
  };

  const handleCancelTimeline = () => {
      setAppState(prev => ({ ...prev, view: View.PREVIEW }));
  };
  
  const handleClearError = () => {
      setAppState(prev => ({ ...prev, error: null }));
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center p-4 sm:p-6 lg:p-8">
      <Header onNewProject={handleNewProject} />
       {appState.error && (
          <div className="w-full max-w-7xl my-4 bg-red-900/50 border border-red-700 text-red-300 px-4 py-3 rounded-lg text-center flex justify-between items-center animate-fade-in">
              <span>{appState.error}</span>
              <button onClick={handleClearError} className="ml-4 font-bold text-lg p-1 leading-none rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-800/50 transition-colors">&times;</button>
          </div>
      )}
      <main className="w-full max-w-7xl flex-grow flex flex-col items-center justify-center">
        {appState.isLoading && <Loader message={appState.loaderMessage} />}
        
        {isStateRestored && !appState.isLoading && !appState.isExporting && appState.view === View.INPUT && (
          <InputForm
            onSubmit={handleCreateClick}
            onTranscribe={handleLyricsTranscription}
            onAdjustLyrics={handleAdjustLyricsFromInput}
            initialData={{
              audio: appState.audioFile,
              image: appState.imageFile,
              lyrics: appState.rawLyrics,
              songName: appState.songName,
              creatorName: appState.creatorName,
              aspectRatio: appState.aspectRatio,
              visualizationStyle: appState.visualizationStyle,
              hindiFont: appState.hindiFont,
              prestructuredLyrics: appState.structuredLyrics.length > 0 && appState.wasTimingAutoGenerated ? appState.structuredLyrics : null,
            }}
          />
        )}
        
        {!appState.isLoading && appState.view === View.PREVIEW && appState.audioUrl && appState.imageUrl && (
          <div className="relative w-full">
            {appState.isExporting && (
              <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center">
                <Loader message={appState.loaderMessage} progress={appState.exportProgress} />
              </div>
            )}
            <VideoPreview
              {...appState}
              lyrics={appState.structuredLyrics}
              onBack={handleBackToInput}
              onExport={handleExport}
              onAdjust={handleAdjustLyrics}
              onSettingsChange={handleSettingsChange}
            />
          </div>
        )}

        {!appState.isLoading && !appState.isExporting && appState.view === View.TIMELINE_EDITOR && appState.audioUrl && (
          <TimelineEditor
            lyrics={appState.structuredLyrics}
            audioUrl={appState.audioUrl}
            duration={appState.audioDuration}
            onSave={handleSaveTimeline}
            onCancel={handleCancelTimeline}
            onSettingsChange={handleSettingsChange}
          />
      </main>
    </div>
  );
};

export default App;
